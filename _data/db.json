{
  "blogs": [
    {
      "id": "1",
      "title": "next.js学习笔记",
      "sub_title": "Server Component VS client component两种组件可以混合使用",
      "body": "version 13 新特性 Server Component VS client component两种组件可以混合使用，尽可能使用服务器组件，性能更好；需要手动配置每一个组件，具体用哪种文一般来说，需要交互的用client component，静态的一般用Server Composerver rendering is good for SEO than client rende服务端渲染可以减少浏览器的JS包大小link标签可以将页面提前在服务器渲染，提高性能streaming & Suspense数据流fetch数据可以使用revalidate（重新验证）这个特性来渲染static pages（与之对应的是数据需要及时处理的dynamic pages），开启后每次刷新页面，会将接收到的数据保存到cache（可能是CDN??），在设置的时间段内重新fetch，不会得到任何的新数据，而是从cache中获取，当过了设置的时间后，fetch获得的数据为最新的。CDN是通过全球分布的服务器提供高效内容传输的网络架构，提高网站加载速度和性能。export default用于将一个函数、类或对象作为模块的默认导出，使其他模块可以直接导入该默认导出的内容404 可以在多个子目录下新建404文件，以展示不同的404loading组件可以用来等待文件加载时展示，配以suspense来使用.",
      "tag": "笔记",
      "update_time": "2023-09-16"
    },
    {
      "id": "2",
      "title": "剑指offer学习笔记",
      "sub_title": "剑指offer学习笔记",
      "body": "<div><ul><li>9.5</li><li>刷完第二题后随机跳到了二叉树，于是顺带复习了二叉树的前中后序遍历，主要看了用栈实现的迭代法,本质上是深度优先搜索。</li><li>迭代法中的前序和后序遍历是有相关联的，前序遍历的中间结点顺序是<b>中左右</b>，而后序遍历是<b>左右中</b>。所以只需把前序遍历压入栈的左右顺序改变，则可变成<b>中右左</b>，然后再反转数组结果即可得到<b>左右中</b>。</li><li>迭代法具体实现中运用了cur来记录当前结点，应记住，二叉树本身在遍历过程中是不会发生变化的，是参照物，变化的是栈和cur，应结合具体的图来理解。</li><li>其次是递归的方法，递归应注意三个地方</li><ul><li>确定递归函数的参数和返回值</li><li>确定终止条件</li><li>确定单层递归的逻辑</li></ul><li></li><li>9.6</li><li>今天刷了3道，第一道是二叉树的深度，其原理和求二叉树的高度有关联</li><li><b>因为代码的逻辑其实是求的根节点的高度，而根节点的高度就是这棵树的最大深度，所以才可以使用后序遍历。</b></li><li>二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。  二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。<br /></p></li><li>第二道是二叉树的镜像，利用前序遍历将左右子树交换即可。</li><li>第三道是“二叉树中和为某一值的路径”，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。叶子节点是指没有子节点的节点。这一题还没有理解。</li><li></li><li>9.7</li><li><b>“从上往下打印二叉树”</b>，这一题用了二叉树层序遍历的思想，也就是广度优先搜索，数据结构使用的是队列，关键在于记录每一层队列的长度，在每一次弹出队列元素时加入该元素的左右孩子，每遍历完一层队列时下一层的元素也就全部加入到队列中，重新记录队列的长度，以此类推，直至队列的长度为0。</li><li><b>“判断是不是平衡二叉树”</b>，这一题考察了平衡二叉树的概念以及二叉树的高度。要判断左右两棵子树的高度差是否大于一，求高度的问题要自下而上遍历，原因是高度是从下往上递增的，所以采用后序遍历的方法。递归的单层逻辑是判断左右两棵子树的高度差，若大于1则返回 -1,否则返回左右两颗子树的最大者再加一，得到父节点的高度，层层返回。最后判断根节点的高度是否等于-1。</li><li>层序遍历可以用来求深度，但不可用来求高度。层序遍历是从上往下逐行遍历，而高度得从下往上遍历。</li><li></li><li>9.8</li><li>“<b>对称的二叉树</b>”，这一题思路会比较难想到，因为是内侧和内侧，外侧和外侧作比较。</li><li>方法用的是<b>后序遍历递归</b>，第一步是确定返回值是布尔值、参数是节点的左右孩子；</li><li>第二步是确认终止条件，可以拿根结点来做参考，当左右孩子其中有一个不为空，另一个为空时，返回false。当两个节点均为空时，返回true。当两个节点均不为空但值不等时，返回false。当左右孩子值相等时，进入下一层递归；</li><li>第三步是确认单层的递归逻辑，应让左孩子的左节点与右孩子的右节点比较，然后是左孩子的右节点和右孩子的左节点比较，然后两种情况做与运算得到结果返回给上一层。</li><li></li><li>9.11</li><li>“<b>在二叉树中找到两个节点的最近公共祖先</b>”同样地，递归三部曲</li><li>当子节点为p,q或空时，直接返回该结点</li><li>接着开始进入递归</li><li>递归逻辑：当左右子节点均不为空时，返回当前节点的值。</li><li>当左节点为空，右节点不为空时，返回右节点的值</li><li>当右节点为空，左节点不为空时，返回左节点的值</li><li>当左右节点均为空时，返回空</li><li>“<b>二叉搜索树的最近公共祖先</b>”没有看参考资料自己做出来了，纪念一下🎈</li><li>What is Binary Search Tree?</li><li><b>Binary Search Tree</b> is a node-based binary tree data structure which has the following properties:</li><ul><li>The left subtree of a node contains only nodes with keys lesser than the node’s key.</li><li>The right subtree of a node contains only nodes with keys greater than the node’s key.</li><li>The left and right subtree each must also be a binary search tree.</li></ul><li>利用二叉搜索树的特点，当节点值位于p,q之间时，此时节点就是LCA</li><li>当节点均小于p，q时，说明LCA在节点的右子树中，于是向右递归。</li><li>当节点均大于p，q时，说明LCA在节点的左子树中，于是向左递归。</li><li>此时，只要遇到和p或q值相同的节点，该结点就是LCA，直接返回即可。</li><li>BTW，Leetcode和牛客上的参数和返回值可能会不一样，要看清楚题目说明</li><li><pre>  * @param root TreeNode类 * @param p int整型 * @param q int整型 * @return int整型 */ function lowestCommonAncestor(root, p, q) { if (root === null) return null; if (root.val === p || root.val === q) return root.val; //若根节点的值位于p,q之间，则根节点为LCA if (root.val > p && root.val < q) return root.val; if (root.val < p && root.val > q) return root.val; //若根节点小于p和q，则进入递归左子树即可，反之同理 if (root.val > p && root.val > q) { let left = lowestCommonAncestor(root.left, p, q); return left; } else if (root.val < p && root.val < q) { let right = lowestCommonAncestor(root.right, p, q); return right; } return null; } </pre></li><li></li><li>9.14</li><li>不知道是不是太久没写算法题，竟然理解错体验，导致把简单的问题复杂化了，审题真的是很重要！！！</li><li>有些简单问题可以用set来解决，尽量少用object，能用map和array就尽量用。</li><li>明天继续刷排序题</li><li></li><li>9.16</li><li>在广图，字节在跳动😀</li><li><code>{{video(https://www.youtube.com/watch?v=XaqR3G_NVoo)}}</code></li><li>这个视频直观地将归并算法演示出来，用艺术作为载体来表达艰涩难懂的算法，大为震撼。</li><li>9.17</li><li>侧重思维的题将思考过程写下来效果更佳。</li><li>9.18</li><li>String.prototype.split()</li><ul><li>可以将字符串按某种规律拆解开来并放到一个数组中</li></ul><li>回溯和递归先确定终止条件，再写单层逻辑，在单层逻辑中进行递归</li></ul></div>",
      "tag": "笔记",
      "update_time": "2023-09-17"
    },
    {
      "id": "3",
      "title": "Fix the footer links",
      "sub_title": "Fix the footer links",
      "body": "<ul><li>package.json很重要，一般从GitHub上下载下来的项目都没有node_module，通过npm install能自动下载package.json中的依赖</li><li>在jsx文件中使用className的原因是js中class也是一个关键字</li><li>react v17不用在文件顶部import react</li><li>react中不能将对象和布尔值返回给浏览器，numbers和string可以</li><li>当要给onClick（）中的函数传值时，可以用一个没有参数的箭头函数来保存需要被传值调用的函数。</li><li><pre>    const handleClick = (e) => { console.log('hello ninjas', e); } const handleClickAgain = (name, e) => { console.log('hello ' + name, e.target); } <button onClick={handleClick}>Click me</button> <button onClick={(e) => handleClickAgain('mario', e)}>Click me again</button> </pre></li><li></li><li></li><li>react hook是react中的特殊函数。</li><li>若要在组件中使用client组件，要在开头加上</li><li><pre>  'use client'; </pre></li><li>props</li><li>组件间传值，可以使用（{blogs,title}）=>{。。。}来直接获取其他组件传过来的值<BlogList blogs={blogs} title='All blogs!'>，无需重新定义🧡</li><li>箭头函数（map、filter）就像一把手术刀一样，见缝插针，无处不在。</li><li></li><li>useEffect不能在useState中使用，不然会无限循环</li><li>useEffect中的回调函数后可以加上[variable，。。],用来展示变更了的variable</li><li></li><li>{}里面的是JS的语句 可以在template里用{}来写条件渲染</li><li>请求错误处理，useState（error），在不用的情况对error进行相应的改变</li><li></li><li>customHook</li><ul><li>有点像用来处理JS逻辑的component，目的也是为了提高代码的复用性。</li><li>可以给customHook传值，customHook中的useEffect检测到传过来的值有变化后，就会进行相应操作</li><li>customHook需要返回一些数据给调用它的页面</li></ul><li>react-router</li><ul><li>当路由变更时用来在前端进行组件更新，而不用每次都向服务器进行页面请求</li><li>在主页写路由更新的时候，要用Exact Match Routes，不然可能会匹配不到想要的页面</li><li><route>要写在<switch>里，<switch>写在<router>里</li><li><link to='/'>相当于<a>，但是无需访问服务器</li><li>abortController用来当fetch的过程中检测到路由的signal有变化时，中断请求。</li><li>useParam()可以用来传递<Link>的参数，供Link to的页面使用，比如说，传递id值，其他页面使用自定义的useFetch来获取博客detail</li></ul><li>submit form</li><ul><li>fetch post 上传到服务器。</li><li>利用ispending来处理上传过程中的页面显示</li></ul><li>useHistory</li><ul><li>可以在触发事件之后重定向</li><li>history.push() history.go()</li></ul></ul>",
      "tag": "趣闻",
      "update_time": "2023-09-18"
    },
    {
      "id": "4",
      "title": "new blog",
      "sub_title": "new blog",
      "body": "这两天进度有点慢，一个是注意力被一些事情分散了，自控力也有所下降，另一个是开始做一些中等难度的题型，很多地方一下子理解不过来，需要时间消化接收。 这几天了解到一些新的开发工具和论坛。 ### codefun 在做实习工作的官网时，有一个需求是要将图片还原成html。鉴于本人想偷懒，于是上网找了一下有没有可以通过AI直接根据图片来生成前端代码的工具，找了一圈发现有一个可以根据UI设计图来生成的网站--**codefun**，而且在即时设计中有相应的插件，于是我就根据图片画了个UI图，然后让codefun帮我生成前端代码。没想到还真的可以！~ ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d8da1f6f46c459e80b825be66b03b9a~tplv-k3u1fbpfcp-watermark.image?) 他除了支持三个CSS平台外，还支持小程序、vue、react和html5等等前端框架。 这个工具一定程度上能减轻前端开发中比较繁重的页面设计工作，相信后面我会继续用到。 ### co-pilot 除此之外，还了解到了co-pilot（这个很早已经火遍全网，觉得功能和gpt不差太多就没有去折腾...），看了油管上的一些视频，发现和chatgpt还是有些不一样，他是能在vscode上用的，不用切换到别的客户端，另一个是他相比chatgpt，更专注于代码的生成上，能自动提示补全代码， 在一些高重复度，业务逻辑简单的JS任务上，我相信会有不错的表现，能减轻前端开发的负担。但是正如其名，co-pilot，英文翻译为副驾驶员，我们应时刻记住我们才是代码的pilot，不能过于依赖这个工具，要将掌控权把握在自己的手上。 ![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0282cf8dd4d4f05aedba85b7697c24f~tplv-k3u1fbpfcp-watermark.image?) 学生开发包能免费白嫖copilot，希望审核大大早点给我通过~球球了 ### v2ex v2ex是一个创意工作者密度很高的论坛，之前听randy的播客也有了解到，但一直没有去explore，前几天搜资料的时候偶然点进了v2ex,并很快捷地注册了一个账号，上面的消息回复都很及时，没想到在国内也能有像HN一样的论坛，值得我日后去explore ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0a1b4aa20794c638f93016fb177261f~tplv-k3u1fbpfcp-watermark.image?) ",
      "tag": "感想",
      "update_time": "2023-09-19"
      
    }
  ]
}